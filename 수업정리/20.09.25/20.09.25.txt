----------------------------------------------------------------------------------------------------------------
지난 시간 복습!
#pragma pack == sturct를 padding없이 만들 때 
sturct에 padding이 존재하는 이유는 속도를 높이기 위함이다
->와 . 의 차이 : ->(sturct의 포인터), .(sturct의 변수)
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
스트림
fp = fopen("a.txt","w"); == output 스트림 == 출력관련 함수
쓰기지만 메모리에서 dB로 넘어가는거기 때문에 메모리 입장에선 출력이다
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
파일 만들고 쓰고 읽기
main() {

	FILE* fp;

	//쓰기부분*******************************************************************************************
	//fp = fopen("a.txt", "w"); // 파일이 없으면 자동생성
								// 파일이 있으면 내용삭제하고 생성
	//fprintf(fp, "%d %s\n", 1, "AAAA");

	//fclose(fp); // 쓰여지는것을 보자

	// 읽기부분*******************************************************************************************
	//int num;
	//char str[100];

	//fp = fopen("a.txt", "r"); // 없으면 error
	//fscanf(fp, "%d %s", &num, str);
	//fclose(fp);
	//printf("% d % s\n", num, str);			// 알아서 모니터로 출력해라
	//fprintf(stdout, "% d % s\n", num, str);	// 모니터로 출력해라

	// update 부분*****************************************************************************************
	//fp = fopen("a.txt", "a"); // 없으면 error
	//fprintf(fp, "%d %s\n", 2, "ccc");	// 모니터로 출력해라
	//fclose(fp);

	// 읽기부분2*******************************************************************************************
	int num;
	char str[100];
	fp = fopen("a.txt", "r"); // 없으면 error
	while (1){
	fscanf(fp, "%d %s", &num, str);

	if (feof(fp) != 0) { //0이면 중간 //??? 끝
		break;
	}
	printf("% d % s\n", num, str);			// 알아서 모니터로 출력해라
	}
	fclose(fp);
}
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
스트림을 구분하는 기준
	1. 텍스트모드
	2. 바이너리 모드 (음원, 영상파일, 그래픽디자인)
텍스트 스트림이 별도 존재하는 이유
	운영체제 별로 개행을 표시하는 방법의 차이가 있다
	1. windows	-/r/n
	2. Linux		- /n
	3. Mac		- /r
파일 입출력 함수들
	1. fgetc, fputc	- 나는 하나씩 옮길거야
	2. fgets, fputs	- 나는 한줄씩 옮길거야
	3. fread, fwrite	- 나는 내가 지정한 크기만큼 옮길거야
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
이미지 오전 11:11 2020-09-25파일 복사하기
main() {

	int cnt;
	char buff[100];
	int tot = 0;

	FILE* wp, * rp;
	rp = fopen("dog.jpg", "rb");
	wp = fopen("강아지1.jpg", "wb");
	while (1)
	{

		cnt = fread(buff, sizeof(char), 100, rp);

		if (cnt < 100)  // 파일의 끝을 만났거나 파일이 깨졌을 경우
		{
			if (feof(rp) != 0)  //끝이라면
			{
				fwrite(buff, sizeof(char), cnt, wp);
				tot += cnt;
				puts("복사 완료\n");
				printf("마지막 복사된 바이트 : %d\n", cnt);
				printf("총 복사된 바이트 : %d\n", tot);
			}
			else
			{
				puts("복사 실패");
			}
			break;
		}

		fwrite(buff, sizeof(char), 100, wp);
		tot += 100;

	}

	fclose(rp);
	fclose(wp);


}
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
파일 위치 지시자의 이동 : fseek
	SEEK_SET(0) : 앞
	SEEK_CUR(1) : 현재
	SEEK_END(2) : 끝
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
동적 메모리 할당
int *p;
p = malloc(4);  == 4바이트 짜리 Heap영역을 만들어라
free == 힙에 할당괸 메모리 공간 해제
ex. int* p = (int*)malloc(sizeof(int));   == malloc의 뒷부분을 해석하면 4이지만 이건 int형 4byte
    char* c = (char*)malloc((sizeof(char)*4)+1);   == malloc의 뒷부분을 해석하면 4이지만 이건 char형*4 = 4byte
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
메모리의 구성
스택영역 : 지역변수와 매개변수가 할당되는 영역 
힙영역 : 프로그래머가 원하는 시점에 메모리 공간에 할당 및 소멸
데이터영역 : 전역변수와 static변수가 할당되는 영역
코드영역 : 실행할 프로그램의 코드가 저장되는 메모리 공간
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
동적메모리 형성시 free선언과 malloc 형성시 순서를 잘 정해야한다
	1. **를 쓸경우 1 -> 2 -> 3번 순으로 malloc을 만들고
		3 -> 2 -> 1번 순으로 free를 해주어야 한다
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
calloc 과 realloc
	1. calloc(4,1)  == 안에 값들이 모두 0으로 자동 초기화
	2. realloc() == ptr이 가리키는 힙의 메모리 공간을 size의 크기로 늘리거나 줄인다
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
선행처리는 컴파일 이전의 처리를 의미합니다
	소스코드 -> 선행처리 -> 컴파일러 -> 링커
	#define 했던것들이 사라진다?

매크로 함수는 일반 함수에 비해 속도가 빠르며 자료형에 따라 별도로 함수를 정의하지 않아도 된다
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------
#define pi 3.14
#define square(x) 1
#define PR(x) printf("%d \n", x)
#define abss(x) x<0 ? (-1*x) : x
#define three_max(a,b,c) a>b? a>c?a:c : b>c?b:c
#define swap(x,y) do{int t ; t=x; x=y; y=t;}while(0)  //  ;  으로 인한 문제를 do while 로 해결


main() {

	printf("%f\n", pi);
	printf("%d\n", square(5));
	PR(3);
	printf("%d\n", abss(-2));
	printf("%d\n", three_max(3, 2, 5));
	int a = 5;
	int b = 3;
	swap(a, b);
	printf("5가 : %d\n3이 : %d",a,b);

}
----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------



















----------------------------------------------------------------------------------------------------------------
스터디 질문!
r+ 는 지우고 쓰는게 아닌 update형식
free
calloc 과 realloc
----------------------------------------------------------------------------------------------------------------